import type { Highlight } from "~/types/common";
import { debounce } from "lodash-es";

export interface Progress {
  enhanceRequestedCount: number;
  generateRequestedCount: number;
  selectedCount: number;
  enhancedCount: number;
  generatedCount: number;
  maxPossible: number;
}

// minGap cannot be set to less than this constant (measured in pages)
export const MIN_GAP_PAGES_TOTAL = 0.5;

export function useAutoIllustration(opts: {
  highlights: Ref<Highlight[]> | Highlight[];
  selectedHighlights: Set<number>;
  // optional page sizing helpers from PdfViewer
  pageAspectRatio?: Ref<number> | number | null;
  onNewPendingOpenIds?: (ids: number[], actionOpts: { enhance: boolean; generate: boolean }) => void; // callback to open editors + run actions for new ids
  onCatchupActions?: (ids: number[], actionOpts: { enhance: boolean; generate: boolean }) => void; // callback to run actions on already-open editors
}) {
  const { highlights, selectedHighlights, onNewPendingOpenIds, onCatchupActions } = opts;
  const pageAspectRatioRef = (opts.pageAspectRatio ?? null) as Ref<number> | number | null;

  const pageAspectRatioValue = computed(() => {
    if (isRef(pageAspectRatioRef) && typeof (pageAspectRatioRef as Ref<number>).value === "number") return (pageAspectRatioRef as Ref<number>).value;
    if (typeof pageAspectRatioRef === "number") return pageAspectRatioRef as number;
    return 1;
  });

  const { hook, callHook } = useNuxtApp();
  hook("custom:markAutoEnhanced", (ids: number[]) => {
    for (const id of ids) processedEnhancedIds.value.add(id);
  });
  hook("custom:markAutoGenerated", (ids: number[]) => {
    for (const id of ids) processedGeneratedIds.value.add(id);
  });

  const { autoIllustration: storage } = useAppStorage();
  const enabled = storage.enabled;
  const enableEnhance = storage.enableEnhance;
  const enableGenerate = storage.enableGenerate;
  const minGapPages = storage.minGapPages;
  const maxGapPages = storage.maxGapPages;
  const minScore = storage.minScore;

  // Tracks IDs by what actions have been requested for them.
  // selectedIds: editors opened; enhancedIds: queued for enhance; generatedIds: queued for generate.
  const selectedIds = ref(new Set<number>());
  const enhancedIds = ref(new Set<number>());
  const generatedIds = ref(new Set<number>());

  // Track IDs that have been actually processed
  const processedEnhancedIds = ref(new Set<number>());
  const processedGeneratedIds = ref(new Set<number>());

  const minGapNorm = computed(() => Math.max(minGapPages.value, MIN_GAP_PAGES_TOTAL));
  const maxGapNorm = computed(() => maxGapPages.value);

  function getYCenterNorm(h: Highlight) {
    // compute a y in 0..1 if possible (don't early return from polygon branch)
    let y: number = 0;
    for (const [page, polys] of Object.entries(h.polygons)) {
      const pageNum = Number(page);
      const ys = polys.map(poly => poly[1]);
      y += pageNum + (Math.min(...ys) + Math.max(...ys)) / 2;
    }
    y /= Object.keys(h.polygons).length; // average across pages if multiple

    // Compute a document-level normalized Y so comparisons across pages are meaningful.
    // Use the unified `pageAspectRatioValue` computed above so both y-centers and
    // gap thresholds share the same scale. If we cannot compute a reliable center
    // return NaN so callers can skip this highlight instead of treating it as 0.
    if (!Number.isFinite(y)) return NaN;
    const pageUnit = pageAspectRatioValue.value ?? 1;
    return y * pageUnit;
  }

  const resolveHighlights = computed(() => {
    return (unref(highlights).filter(h => h.score !== undefined && h.score !== null) || []) as (Highlight & { score: number })[];
  });

  /*
  Auto-illustration selection algorithm

  This composable implements an in-order, lookahead selection algorithm used to
  automatically choose highlights for which `ImageEditor` instances should open.

  Key points:
  - Input: a document-ordered array of `Highlight` objects (the `highlights` arg).
  - Output: an ordered array of selected highlight ids. The composable itself
    adds those ids into the provided `selectedHighlights` set (union semantics)
    when `enabled` is true, and leaves manually-selected ids untouched.
  - Gap mapping: 1 line â‰ˆ 0.01 normalized page height. `minGapLines` and
    `maxGapLines` are provided in lines and converted to normalized units by
    multiplying by 0.01. This mapping is used to compute the lookahead window
    (`maxGap`) and the skip distance after choosing an item (`minGap`).
  - Algorithm: iterate the highlights in document order. For each position i,
    consider the lookahead window of segments whose vertical center is within
    `maxGap` of highlight i. From that window choose the segment with the
    highest score (respecting `minScore` if set). After selecting, advance the
    scan to the first segment whose center lies beyond the chosen segment's
    center plus `minGap` to enforce spacing.
  */
  function runSelectionOnce(): number[] {
    const list = resolveHighlights.value;
    const selected: number[] = [];
    const n = list.length;

    // scale the min/max gap by the page unit used in getYCenterNorm
    // `minGapNorm`/`maxGapNorm` are in pages; multiply by `pageUnit` to match
    // the same document-level units produced by `getYCenterNorm`.
    const pageUnit = pageAspectRatioValue.value;
    const minGap = minGapNorm.value * pageUnit;
    const maxGap = maxGapNorm.value * pageUnit;
    const minScoreVal = minScore.value;

    // Precompute y centers and scores to avoid repeated work inside inner loops
    const yCenters: number[] = new Array(n);
    const scores: number[] = new Array(n);
    for (let i = 0; i < n; i++) {
      const it = list[i];
      const yc = it ? getYCenterNorm(it) : NaN;
      yCenters[i] = Number.isFinite(yc) ? yc : NaN;
      scores[i] = it.score;
    }

    for (let i = 0; i < n; i++) {
      const base = list[i];
      if (!base) continue;
      const baseY = yCenters[i];
      if (!Number.isFinite(baseY)) continue;

      // find window end index where candidate Y - baseY <= maxGap
      let endIdx = i;
      while (endIdx < n && Number.isFinite(yCenters[endIdx]) && (yCenters[endIdx] - baseY) <= maxGap) {
        endIdx++;
      }
      endIdx = endIdx - 1; // inclusive
      if (endIdx < i) continue;

      // find best candidate index in the window (highest score, tie -> earlier)
      let bestIdx = -1;
      let bestScore = -Infinity;
      for (let j = i; j <= endIdx; j++) {
        const candY = yCenters[j];
        if (!Number.isFinite(candY)) continue;
        const s = scores[j];
        if (minScoreVal !== null && s < minScoreVal) continue;
        if (s > bestScore || (s === bestScore && (bestIdx === -1 || j < bestIdx))) {
          bestScore = s;
          bestIdx = j;
        }
      }
      if (bestIdx === -1) continue;

      // gather valid candidates only up to and including bestIdx
      const candidates: { idx: number; score: number; y: number }[] = [];
      for (let j = i; j <= bestIdx; j++) {
        const candY = yCenters[j];
        if (!Number.isFinite(candY)) continue;
        const s = scores[j];
        if (minScoreVal !== null && s < minScoreVal) continue;
        candidates.push({ idx: j, score: s, y: candY });
      }

      // sort by score desc, tie-break by document order (y asc)
      candidates.sort((a, b) => {
        if (b.score !== a.score) return b.score - a.score;
        return a.y - b.y;
      });

      // greedily pick candidates by score while enforcing minGap around each pick
      const chosenIdxs: number[] = [];
      const chosenYs: number[] = [];
      for (const c of candidates) {
        let ok = true;
        for (const yy of chosenYs) {
          if (Math.abs(c.y - yy) <= minGap) {
            ok = false;
            break;
          }
        }
        if (!ok) continue;
        const chosen = list[c.idx];
        if (chosen && typeof chosen.id === "number") {
          selected.push(chosen.id);
          chosenIdxs.push(c.idx);
          chosenYs.push(c.y);
        }
      }

      // if we picked any in this window, advance i to the first index beyond the
      // last-picked's y + minGap to avoid overlapping subsequent windows
      if (chosenIdxs.length > 0) {
        const lastChosenIdx = chosenIdxs.reduce((a, b) => Math.max(a, b), -1);
        const lastChosenY = yCenters[lastChosenIdx];
        let k = lastChosenIdx + 1;
        while (k < n && Number.isFinite(yCenters[k]) && (yCenters[k] - lastChosenY) <= minGap) k++;
        i = k - 1;
      }
    }

    return selected;
  }

  function runPass() {
    const ids = runSelectionOnce();
    const newlySelected: number[] = [];
    const catchupEnhance: number[] = [];
    const catchupGenerate: number[] = [];

    for (const id of ids) {
      if (!selectedIds.value.has(id)) {
        selectedHighlights.add(id);
        selectedIds.value.add(id);
        newlySelected.push(id);
        if (enableEnhance.value) enhancedIds.value.add(id);
        if (enableGenerate.value) generatedIds.value.add(id);
      } else {
        if (enableEnhance.value && !enhancedIds.value.has(id)) {
          enhancedIds.value.add(id);
          catchupEnhance.push(id);
        }
        if (enableGenerate.value && !generatedIds.value.has(id)) {
          generatedIds.value.add(id);
          catchupGenerate.push(id);
        }
      }
    }

    console.log(`[AutoIllustration] Selected ${newlySelected.length} new, ${catchupEnhance.length} catchup-enhance, ${catchupGenerate.length} catchup-generate`);

    if (newlySelected.length && onNewPendingOpenIds) {
      onNewPendingOpenIds(newlySelected, { enhance: enableEnhance.value, generate: enableGenerate.value });
    }

    if (catchupEnhance.length && onCatchupActions) {
      onCatchupActions(catchupEnhance, { enhance: true, generate: false });
    }
    if (catchupGenerate.length && onCatchupActions) {
      onCatchupActions(catchupGenerate, { enhance: false, generate: true });
    }

    return newlySelected;
  }

  function clearAutoSelections() {
    for (const id of selectedIds.value) selectedHighlights.delete(id);
    callHook("custom:clearAutoImageEditors", Array.from(selectedIds.value));
    selectedIds.value.clear();
    enhancedIds.value.clear();
    generatedIds.value.clear();
    processedEnhancedIds.value.clear();
    processedGeneratedIds.value.clear();
  }

  // reactively run when highlights change, but only if enabled
  const debouncedRunPass = debounce(runPass, 500, { leading: true, trailing: true });
  watch([resolveHighlights, enabled], () => {
    if (enabled.value) {
      debouncedRunPass();
    }
  }, { deep: true, flush: "post" });

  function getMaxPossible() {
    const list = resolveHighlights.value;
    const n = list.length;
    const pageUnit = pageAspectRatioValue.value;
    const minGap = minGapNorm.value * pageUnit;
    const minScoreVal = minScore.value;

    // Precompute y centers and scores similar to runSelectionOnce
    const yCenters: number[] = new Array(n);
    const scores: number[] = new Array(n);
    for (let i = 0; i < n; i++) {
      const it = list[i];
      const yc = it ? getYCenterNorm(it) : NaN;
      yCenters[i] = Number.isFinite(yc) ? yc : NaN;
      scores[i] = it.score;
    }

    // Greedy earliest-pick algorithm maximizes count under spacing constraint.
    let count = 0;
    let i = 0;
    while (i < n) {
      if (!Number.isFinite(yCenters[i])) {
        i++;
        continue;
      }
      const s = scores[i];
      if (minScoreVal !== null && s < minScoreVal) {
        i++;
        continue;
      }
      // pick this one
      count++;
      const chosenY = yCenters[i];
      // advance to first index whose y is > chosenY + minGap
      let k = i + 1;
      while (k < n && Number.isFinite(yCenters[k]) && (yCenters[k] - chosenY) <= minGap) k++;
      i = k;
    }
    return count;
  }

  return {
    enabled,
    minGapPages,
    maxGapPages,
    minScore,
    runPass,
    clearAutoSelections,
    enableEnhance,
    enableGenerate,
    progress: computed(() => {
      return {
        enhanceRequestedCount: enhancedIds.value.size,
        generateRequestedCount: generatedIds.value.size,
        selectedCount: selectedIds.value.size,
        enhancedCount: processedEnhancedIds.value.size,
        generatedCount: processedGeneratedIds.value.size,
        maxPossible: getMaxPossible(),
      } as Progress;
    }),
  };
}

